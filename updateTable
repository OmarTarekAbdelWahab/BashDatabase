db=$1
maxS=10
minS=1

check_string() {
        local name=$1
        [[ ${#name} -gt $maxS || ${#name} -lt $minS || "$name" =~ " " ]]
}

error_exit() {
    echo "Error +${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): } $1" >&2
    exit 1
}

if check_string "$db" ; then
        error_exit "Invalid Database Name"
fi

DIR="./databases/$db"

if [ ! -d $DIR ]; then
        error_exit "Database Doesn't Exist"
fi

tables=""

if ! [ -z "$(find $DIR -maxdepth 0 -type d -empty)" ]; then
        zenity --info --title="$db" --text="No Tables Yet in Database: $db" --width=400 --height=200 2> /dev/null
        exit 0
fi

for tName in "$DIR"/*; do
        tName=$(basename $tName)
        tables[$i]=$tName
        i=$((i+1))
done
while true; do
	table=$(zenity --list \
	        --title="$db($table)" \
		--width=500 \
		--height=300 \
	        --column="Tables" \
	        "${tables[@]}" 2> /dev/null
	)

	if [ $? -ne 0 ]; then
		exit 0
	fi
	if [ -z "$table" ]; then
		continue
	fi
	break
done

schema="$DIR/$table/schema"

if [ ! -f $schema ]; then
	error_exit "Table Doesn't Exist"
fi

i=0
n=0
primary=0
declare -a names=()
declare	-a defaults=()
declare	-a types=()
arrI=0

while IFS= read -r line; do
	if (( i == 1 )); then
		n=$line
	elif (( i == 2 )); then
		primary=$line
	elif (( i > 2 )); then
		names[$arrI]=$(echo $line | cut -d' ' -f2)
		types[$arrI]=$(echo $line | cut -d' ' -f3)
		
		hasD=$(echo $line | cut -d' ' -f1)
		if [[ "$hasD" == "+" ]]; then
			defaults[$arrI]=$(echo $line | cut -d' ' -f4)
		else
			defaults[$arrI]=""
		fi
		arrI=$((arrI+1))
	fi
	i=$((i+1))
			
done < "$schema"

declare -a row=()

data=$DIR/$table/data
if [ ! -f $data ]; then
        touch $data
fi

for (( j = 0; j < $n; j++ )); do
	name=${names[$j]}
	type=${types[$j]}
	txt="Enter Search Value for Column $name($type)"
	ent="$name($type)"
	f=0
	while [[ $f == 0 ]]; do
		input=$(zenity --forms \
                	--title="$db($table)" \
                	--text="$txt" \
                	--add-entry="$ent" 2> /dev/null
        	)
		if [ $? -ne 0 ]; then
			exit 0
	        fi
		if [ -z "$input" ]; then
			input=""
			f=1
		else

			if [[ "$type" == "Integer" ]]; then
				if [[ ! "$input" =~ ^[-+]?[0-9]+$ ]]; then
		                        txt="$name Value Should Be an Integer"
                		else
					f=1
				fi
			elif [[ "$type" == "Boolean" ]]; then
				if [[ "$input" != true && "$input" != false ]]; then
					txt="$name Value Must be Either true or false"
				else
					f=1
				fi
			else
				f=1
			fi
		fi
	done
	row[$j]="$input"
done

declare -a output=()
outputI=0
declare -a delIndices=()
delI=0
rowIndex=0

while IFS= read -r line
do
	((rowIndex++))
	take=1
	for (( j = 1; j <= n; j++ )); do
		checkVal="${row[(($j-1))]}"
		if [ -z "$checkVal" ]; then
			continue
		fi	
		curVal=$( echo "$line" | cut -d"|" -f$j )
		if [[ "$curVal" != "$checkVal" ]]; then
			take=0
			break
		fi
	done
	if (( take == 1 )); then
		delIndices[$delI]=$rowIndex
		((delI++))
		for (( strI = 1; strI <= n; strI++ )); do
			field=$( echo "$line" | cut -d"|" -f$strI )
			output[$outputI]="$field"
			outputI=$((outputI+1))
		done
	fi
done < "$data"

if (( delI == 0 )); then
	echo Nothing to Delete!
	exit 0
fi

args=(zenity --list --title="$db($table)" --width=500 --height=300 --text="Are you Sure You Want To Update These Rows?")

for (( j = 0; j < n; j++ )); do
	args+=(--column="${names[$j]}")
done

for (( j = 0; j < outputI; j++)); do
	args+=("${output[$j]}")
done

"${args[@]}" 2> /dev/null
if [ $? -ne 0 ]; then
	exit 0
fi

#cmd=""
#for j in "${delIndices[@]}"; do
#	cmd+="${j}d;"	
#done
#
#sed -i "$cmd" "$data"

previousIds=$( cat $data | cut -d'|' -f$primary )

declare -a newData=()
for (( j = 0; j < $n; j++ )); do
        name=${names[$j]}
        type=${types[$j]}
        txt="Enter New Value for Column $name($type) (Leave Empty to Keep Old Value)"
        ent="$name($type)"
        f=0
	if (( "${#delIndices[@]}" > 1 && j+1 == primary )); then
		f=1
		input=""
	fi
	while [[ $f == 0 ]]; do
                input=$(zenity --forms \
                        --title="$db($table)" \
                        --text="$txt" \
                        --add-entry="$ent" 2> /dev/null
                )
                if [ $? -ne 0 ]; then
			exit 0
                fi
                if [ -z "$input" ]; then
                        input=""

                        f=1
                else

                        if [[ "$type" == "Integer" ]]; then
                                if [[ ! "$input" =~ ^[-+]?[0-9]+$ ]]; then
                                        txt="$name Value Should Be an Integer"
                                else
                                        f=1
                                fi
                        elif [[ "$type" == "Boolean" ]]; then
                                if [[ "$input" != true && "$input" != false ]]; then
                                        txt="$name Value Must be Either true or false"
                                else
                                        f=1
                                fi
                        else
                            	f=1
                        fi

			if (( $j+1 == $primary )); then
                                if echo "$previousIds" | grep -q ^"$input"$; then
                                        txt="Primary Key Value Already Exists"
                                        f=0
                                fi
                        fi

                fi
        done
	newData[$j]="$input"
done


tmp=$DIR/$table/tmp
touch tmp

delI=0
rowIndex=0

while IFS= read -r line
do
  	((rowIndex++))

	if [[ "$rowIndex" == "${delIndices[$delI]}" ]]; then
		((delI++))
		newRow=""
		for (( j = 1; j <= n; j++ )); do
                        field=$( echo "$line" | cut -d"|" -f$j )
			if [[ -z "${newData[(($j-1))]}" ]]; then
				newRow+="|${field}"
			else
				newRow+="|${newData[(($j-1))]}"
			fi
                done
		newRow="${newRow:1}"
		echo "$newRow" >> "$tmp"
	else
		echo "$line" >> "$tmp"
	fi
done < "$data"

mv "$tmp" "$data"
